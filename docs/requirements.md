# ТЗ: Мини‑планировщик Cash Flow (Python + Web + DB)

## 1. Цели и общая логика

Мини‑планировщик cash flow:

1. Читает файл с историческими данными (Excel/CSV).
2. Строит прогноз на следующий месяц по каждой статье (и при необходимости по дням/неделям).
3. Показывает пользователю в веб‑интерфейсе таблицу с тремя ключевыми колонками:
   - **Прогнозные значения** (read‑only).
   - **Корректировки** (input, редактируется пользователем).
   - **Итоговый результат** = Прогноз + Корректировки (read‑only).
4. Пользователь может сохранить текущие значения (включая корректировки) в базу данных.

Приложение задумывается как прототип/микро‑сервис, который можно развивать (улучшать модель прогноза, расширять UI, добавлять авторизацию и т.д.).

---

## 2. Функциональные требования

### 2.1. Исторические данные и прогноз

**Формат входного файла**

- Поддерживаемые форматы:
  - Excel (`.xlsx`) или CSV.
- Обязательные колонки (базовый вариант):
  - `date` — дата операции / дня (формат: `YYYY-MM-DD` или распознаваемый `pandas`).
  - `category` — статья cash flow (например, "Поступления от клиентов", "Платежи поставщикам").
  - `amount` — сумма (числовое значение, может быть положительным или отрицательным).
- Требование:
  - Названия колонок должны быть конфигурируемыми (через `config.py` или аналогичный конфиг).

**Логика прогноза (минимально жизнеспособная версия)**

Цель: реализовать простую и прозрачную модель прогноза, которую легко заменить на более сложную в будущем.

- Базовый подход:
  - Рассчитывать прогноз на **следующий календарный месяц** по каждой `category`.
  - Использовать агрегированные исторические данные:
    - Группировка по `month` и `category`.
    - Рассчитать суммарный cash flow по каждой категории за месяц.
  - Прогнозная сумма по каждой категории для следующего месяца:
    - Среднее значение за последние **N** месяцев (например, 3 последних месяца, параметр в конфиге: `FORECAST_LOOKBACK_MONTHS`).
- Период прогноза:
  - Если максимум `date` в историческом файле = `2025-11-30`, прогнозируем `2025-12` (условно `forecast_period` = `2025-12`).
- Требование:
  - Вынести логику прогноза в отдельный модуль/функцию, чтобы в будущем легко заменить на Prophet/ML-модель.

**Выходные данные прогноза**

Результирующая таблица прогноза на следующий месяц должна содержать:

- `period` — период прогноза (например, строка `"2025-12"` или отдельное поле `year` + `month`).
- `category` — статья cash flow.
- `forecast_amount` — рассчитанное прогнозное значение.
- `adjustment` — корректировка пользователя (по умолчанию 0).
- `final_amount` — итог = `forecast_amount` + `adjustment`.

---

### 2.2. Веб‑интерфейс

Фреймворк: допускаются два варианта реализации:

- **Вариант A (рекомендуемый для быстрого прототипа)**: Streamlit.
- **Вариант B**: FastAPI + простой HTML/JS (Jinja2).

Ниже требования к функционалу, независимо от выбранного фреймворка.

#### 2.2.1. Главная страница /app

Элементы интерфейса:

1. **Загрузка файла**:
   - Элемент upload (кнопка/поле), позволяющий выбрать и загрузить Excel/CSV.
   - После загрузки файл должен быть прочитан и приведен к ожидаемому формату (через модуль `io_historical`).

2. **Кнопка "Рассчитать прогноз"**:
   - При нажатии:
     - Парсится загруженный файл.
     - Исторические данные передаются в модуль прогноза.
     - Полученная таблица прогноза отображается в виде редактируемой таблицы с тремя ключевыми колонками.

3. **Таблица прогноза**:
   - Колонки:
     - `category`
     - `period` (например, `2025-12`)
     - `forecast_amount` (read‑only).
     - `adjustment` (редактируемое числовое поле).
     - `final_amount` (read‑only, рассчитывается как `forecast_amount + adjustment`).
   - Поведение:
     - При изменении значения в колонке `adjustment`:
       - `final_amount` должен пересчитываться автоматически (на клиенте или на сервере, в зависимости от выбранной технологии).
   - Внизу таблицы:
     - Отображать суммарные значения:
       - Σ `forecast_amount`
       - Σ `adjustment`
       - Σ `final_amount`.

4. **Кнопка "Сохранить в БД"**:
   - Доступна после расчета прогноза.
   - При нажатии:
     - Текущее содержимое таблицы (включая все корректировки) записывается в базу данных как один сценарий (scenario).
     - После успешного сохранения выводится:
       - Сообщение об успехе.
       - ID сохраненного сценария (например, `Scenario ID: 42`).

5. **(Опционально) Форма ввода описания сценария**:
   - Поле `description` для комментария к сценарию (перед сохранением).

#### 2.2.2. Страница "История" (опционально)

- Адрес: `/history` (или кнопка "История" на главной странице).
- Функционал:
  - Отображать список сохраненных сценариев:
    - `id`
    - `created_at`
    - `forecast_period`
    - `description` (если есть)
    - Суммарный `final_amount` по сценарию.
  - При клике на конкретный сценарий:
    - Отображать таблицу с сохраненными строками (read‑only).

---

## 3. База данных

Для прототипа используется **SQLite**.

### 3.1. Структура таблиц

#### Таблица `scenarios`

- `id` — INTEGER, PRIMARY KEY, AUTOINCREMENT.
- `created_at` — DATETIME (время сохранения сценария).
- `created_by` — TEXT (пока можно просто строка, например "user"; в будущем — связка с системой пользователей).
- `forecast_period` — TEXT (например, `"2025-12"`).
- `description` — TEXT, NULLABLE (комментарий пользователя).

#### Таблица `scenario_lines`

- `id` — INTEGER, PRIMARY KEY, AUTOINCREMENT.
- `scenario_id` — INTEGER, FOREIGN KEY → `scenarios.id`.
- `category` — TEXT.
- `period_date` — TEXT или DATE:
  - В базовой версии можно хранить тот же `forecast_period` или конкретную дату, если нужна детализация.
- `forecast_amount` — REAL.
- `adjustment_amount` — REAL.
- `final_amount` — REAL.

### 3.2. Логика сохранения

- При нажатии пользователем "Сохранить в БД":
  1. Создать новую запись в `scenarios`:
     - `created_at` = текущее время.
     - `created_by` = условный пользователь (например, "user").
     - `forecast_period` = период, на который построен прогноз.
     - `description` = из UI (если передано).
  2. Для каждой строки таблицы прогноза:
     - Создать запись в `scenario_lines` с заполнением всех полей.
- Требование:
  - Сохранение должно быть атомарным: либо сохраняются все строки сценария, либо ни одной (транзакция).

---

## 4. Технические требования

### 4.1. Стек технологий

- Язык: **Python 3.10+**.
- Веб‑фреймворк (один из вариантов):
  - **Streamlit** — для быстрого прототипа и интерактивного интерфейса.
  - **FastAPI** + HTML (через Jinja2) — более классический backend + минимальный frontend.
- База данных: **SQLite**.
  - Работа через `sqlite3` или **SQLAlchemy** (предпочтительно для масштабируемости).
- Работа с файлами Excel/CSV:
  - `pandas` (основная библиотека обработки табличных данных).
  - `openpyxl` (для чтения `.xlsx`, если требуется).

### 4.2. Архитектура кода (рекомендуемая структура)

Проект можно организовать следующим образом:

project_root/
app.py # Точка входа (Streamlit / FastAPI)
config.py # Конфигурация
requirements.txt # Зависимости

core/
io_historical.py # Чтение/нормализация исторических данных
forecast.py # Логика расчета прогноза
db.py # Подключение к БД, функции сохранения/чтения
models.py # Описание моделей/ORM (если используем SQLAlchemy)


**Модуль `config.py`**

- Хранит:
  - `FORECAST_LOOKBACK_MONTHS = 3`
  - `DB_URL = "sqlite:///cashflow.db"` (или путь к файлу SQLite).
  - Настройки колонок входного файла, например:

    ```
    HIST_COL_DATE = "date"
    HIST_COL_CATEGORY = "category"
    HIST_COL_AMOUNT = "amount"
    ```

**Модуль `io_historical.py`**

- Функции:
  - `load_history_from_file(file_path_or_buffer) -> pd.DataFrame`
    - Определяет тип файла (Excel/CSV).
    - Читает файл с помощью `pandas`.
    - Переименовывает колонки в стандартные (`date`, `category`, `amount`).
    - Приводит типы данных (`date` → datetime, `amount` → float).

**Модуль `forecast.py`**

- Основная функция:
  - `build_cashflow_forecast(df_history: pd.DataFrame) -> pd.DataFrame`
    - Ожидание на вход:
      - DataFrame с колонками: `date`, `category`, `amount`.
    - Шаги:
      1. Добавить колонку `month` на основе `date` (например, `2025-11`).
      2. Агрегировать данные по `month` + `category` (сумма `amount`).
      3. Определить последний месяц в данных и следующий месяц как `forecast_period`.
      4. Для каждой `category` рассчитать среднее значение за последние `FORECAST_LOOKBACK_MONTHS` месяцев.
      5. Вернуть DataFrame со столбцами:
         - `period` (строка с периодом прогноза, одинаковая для всех строк, например `"2025-12"`).
         - `category`.
         - `forecast_amount`.
         - `adjustment` (0 по умолчанию).
         - `final_amount` (= `forecast_amount` на этапе расчета, до корректировок пользователя).

**Модуль `db.py` / `models.py`**

- Подключение к SQLite.
- Определение таблиц `scenarios` и `scenario_lines` (через SQLAlchemy или сырые SQL).
- Функции:
  - `init_db()` — создание таблиц при первом запуске.
  - `save_scenario(forecast_period, description, rows, created_by="user") -> scenario_id`
    - `rows` — список dict или объектов с полями:
      - `category`, `period_date`, `forecast_amount`, `adjustment_amount`, `final_amount`.
  - `get_scenarios_list() -> list[...]`
  - `get_scenario_lines(scenario_id) -> list[...]`

---

## 5. API / Веб‑слой (для варианта FastAPI)

Если используется **FastAPI**, то:

### 5.1. Эндпоинты

1. `POST /upload-file`
   - Вход:
     - Файл (multipart/form-data).
   - Действия:
     - Передать файл в `io_historical.load_history_from_file`.
     - Передать результат в `forecast.build_cashflow_forecast`.
   - Выход (JSON):
     - Список строк прогноза с полями:
       - `period`
       - `category`
       - `forecast_amount`
       - `adjustment` (0)
       - `final_amount` (равно `forecast_amount`)

2. `POST /save-scenario`
   - Вход (JSON):
     ```
     {
       "forecast_period": "2025-12",
       "description": "опционально",
       "rows": [
         {
           "category": "Поступления от клиентов",
           "period_date": "2025-12",
           "forecast_amount": 1000000.0,
           "adjustment_amount": 50000.0,
           "final_amount": 1050000.0
         }
       ]
     }
     ```
   - Действия:
     - Вызвать `db.save_scenario(...)`.
   - Выход:
     ```
     {
       "status": "success",
       "scenario_id": 42
     }
     ```

3. `GET /scenarios`
   - Выход:
     - Список сценариев (`id`, `forecast_period`, `created_at`, `description`, сумма `final_amount`).

4. `GET /scenarios/{id}`
   - Выход:
     - Список строк сценария (`category`, `period_date`, `forecast_amount`, `adjustment_amount`, `final_amount`).

---

## 6. Требования к качеству и расширяемости

- Код должен быть разделен на модули (IO, прогноз, БД, веб‑слой).
- Логику прогноза нужно сделать **легко заменяемой**:
  - В перспективе заменить среднее за N месяцев на:
    - Prophet.
    - ML‑модель (scikit‑learn / TensorFlow и т.д.).
- Должна быть простая точка входа (`app.py`), чтобы можно было:
  - Запустить Streamlit: `streamlit run app.py`.
  - Или запустить FastAPI через Uvicorn: `uvicorn app:app --reload`.
- Конфигурация (пути к БД, параметры прогноза, имена колонок) — вне кода (через `config.py` или `.env`).

---

## 7. Ожидаемый результат

На выходе нужен работающий прототип, который:

1. Позволяет загрузить файл с историей cash flow.
2. Считает прогноз на следующий месяц по статьям.
3. Показывает в веб‑интерфейсе:
   - Прогноз.
   - Поле для ручной корректировки.
   - Итог (прогноз + корректировка).
4. Позволяет сохранить результаты в SQLite.
5. Имеет минимально аккуратный, но понятный код и структуру проекта, чтобы можно было развивать дальше.
